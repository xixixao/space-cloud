// Generated by CoffeeScript 1.6.2
(function() {
  var Q, compile, connect, defineModels, models, mongoose, populate, shallowify, wipe;

  Q = require('q');

  (require('./q-each'))(Q);

  mongoose = require('mongoose');

  (require('./mongoose-promise-save'))(mongoose);

  defineModels = function() {
    var Answer, CommentA, CommentQ, Event, File, Question, Schema, Topic, User, answerSchema, commentASchema, commentQSchema, eventSchema, fileSchema, questionSchema, topicPermission, topicSchema, userSchema;

    Schema = mongoose.Schema;
    topicPermission = Schema({
      code: {
        type: String,
        ref: 'Topic'
      },
      permission: String
    });
    eventSchema = Schema({
      type: String,
      url: {},
      model: String,
      timestamp: {
        type: Date,
        "default": Date.now
      },
      topicCode: {
        type: String,
        ref: 'Topic'
      }
    });
    Event = mongoose.model('Event', eventSchema);
    userSchema = Schema({
      name: String,
      _id: {
        type: String,
        unique: true,
        dropDups: true
      },
      password: String,
      email: String,
      facebook: String,
      topics: [topicPermission]
    });
    User = mongoose.model('User', userSchema);
    commentASchema = Schema({
      timestamp: {
        type: Date,
        "default": Date.now
      },
      owner: {
        type: String,
        ref: 'User'
      },
      text: String
    });
    commentASchema.methods.shallow = function() {
      return shallowify(this, CommentA);
    };
    commentASchema.statics.findByURL = function(url) {
      return Answer.findByURL(url).then(function(_arg) {
        var answer, comment, parents;

        answer = _arg[0], parents = _arg[1];
        comment = answer.comments.id(url.commentId);
        parents.answer = answer;
        return [comment, parents];
      });
    };
    commentASchema.statics.findShallowByURL = function(url) {
      return compile(CommentA.findByURL(url));
    };
    CommentA = mongoose.model('CommentA', commentASchema);
    answerSchema = Schema({
      timestamp: {
        type: Date,
        "default": Date.now
      },
      owner: {
        type: String,
        ref: 'User'
      },
      comments: [commentASchema],
      text: String,
      votesFor: [
        {
          type: String,
          ref: 'User'
        }
      ],
      priority: Number
    });
    answerSchema.methods.shallow = function() {
      return shallowify(this, Answer, ['comments']);
    };
    answerSchema.statics.findByURL = function(url) {
      return Question.findByURL(url).then(function(_arg) {
        var answer, parents, question;

        question = _arg[0], parents = _arg[1];
        answer = question.answers.id(url.answerId);
        parents.question = question;
        return [answer, parents];
      });
    };
    answerSchema.statics.findShallowByURL = function(url) {
      return compile(Answer.findByURL(url));
    };
    Answer = mongoose.model('Answer', answerSchema);
    commentQSchema = Schema({
      timestamp: {
        type: Date,
        "default": Date.now
      },
      owner: {
        type: String,
        ref: 'User'
      },
      text: String
    });
    commentQSchema.methods.shallow = function() {
      return shallowify(this, CommentQ);
    };
    commentQSchema.statics.findByURL = function(url) {
      return Question.findByURL(url).then(function(_arg) {
        var comment, parents, question;

        question = _arg[0], parents = _arg[1];
        comment = question.comments.id(url.commentId);
        parents.question = question;
        return [comment, parents];
      });
    };
    commentQSchema.statics.findShallowByURL = function(url) {
      return compile(CommentQ.findByURL(url));
    };
    CommentQ = mongoose.model('CommentQ', commentQSchema);
    questionSchema = Schema({
      createdTime: {
        type: Date
      },
      modifiedQuestionTime: {
        type: Date
      },
      modifiedTime: {
        type: Date
      },
      owner: {
        type: String,
        ref: 'User'
      },
      position: String,
      answers: [answerSchema],
      comments: [commentQSchema],
      text: String
    });
    questionSchema.methods.shallow = function() {
      return shallowify(this, Question, ['answers', 'comments']);
    };
    questionSchema.statics.findByURL = function(url) {
      return File.findByURL(url).then(function(_arg) {
        var file, parents, question;

        file = _arg[0], parents = _arg[1];
        question = file.questions.id(url.questionId);
        parents.file = file;
        return [question, parents];
      });
    };
    questionSchema.statics.findShallowByURL = function(url) {
      return compile(Question.findByURL(url));
    };
    Question = mongoose.model('Question', questionSchema);
    fileSchema = Schema({
      _id: {
        type: String,
        unique: true
      },
      path: String,
      name: String,
      owner: {
        type: String,
        ref: 'User'
      },
      questions: [questionSchema],
      type: String,
      date: {
        type: Date
      }
    });
    fileSchema.methods.shallow = function() {
      return shallowify(this, File, ['questions']);
    };
    fileSchema.statics.findByURL = function(_arg) {
      var fileId, topicId;

      topicId = _arg.topicId, fileId = _arg.fileId;
      return Topic.findByURL({
        topicId: topicId
      }).then(function(_arg1) {
        var topic;

        topic = _arg1[0];
        return [
          topic.files.id(fileId), {
            topic: topic
          }
        ];
      });
    };
    fileSchema.statics.findShallowByURL = function(url) {
      return compile(File.findByURL(url));
    };
    File = mongoose.model('File', fileSchema);
    topicSchema = Schema({
      name: String,
      _id: {
        type: String,
        unique: true
      },
      files: [fileSchema],
      types: [String]
    });
    topicSchema.methods.shallow = function() {
      return Q.when(this.toObject({
        transform: function(doc, ret) {
          delete ret.files;
          delete ret.types;
          return ret;
        }
      }));
    };
    topicSchema.statics.findByURL = function(_arg) {
      var topicId;

      topicId = _arg.topicId;
      return Q.ninvoke(Topic, 'findById', topicId).then(function(topic) {
        if (topic == null) {
          throw [404, "topic not found " + topicId];
        }
        return [topic];
      });
    };
    Topic = mongoose.model('Topic', topicSchema);
    return {
      Topic: Topic,
      User: User,
      File: File,
      Question: Question,
      CommentA: CommentA,
      CommentQ: CommentQ,
      Answer: Answer,
      Event: Event
    };
  };

  module.exports = models = defineModels();

  module.exports.named = function(name) {
    return mongoose.model(name);
  };

  shallowify = function(doc, model, dontShow) {
    return Q.ninvoke(model, 'populate', doc, {
      path: 'owner',
      select: 'name _id'
    }).then(function(doc) {
      return doc.toObject({
        transform: function(doc, ret) {
          var key, _i, _len;

          if (dontShow != null) {
            for (_i = 0, _len = dontShow.length; _i < _len; _i++) {
              key = dontShow[_i];
              delete ret[key];
            }
          }
          return ret;
        }
      });
    });
  };

  compile = function(promise) {
    return promise.then(function(_arg) {
      var doc, map;

      doc = _arg[0], map = _arg[1];
      return doc.shallow().then(function(ret) {
        return Q.map(map, function(parent, label) {
          return parent.shallow().then(function(plain) {
            return ret[label] = plain;
          });
        }).then(function() {
          return ret;
        });
      });
    });
  };

  connect = function() {
    var db;

    mongoose.connect("mongodb://localhost/test");
    db = mongoose.connection;
    return db.on("error", function(error) {
      return console.error("DB error:(are you running the database?)\n", error);
    });
  };

  wipe = function() {
    var db;

    db = mongoose.connection;
    return Q.map(db.collections, function(collection) {
      return Q.ninvoke(collection, 'drop');
    });
  };

  populate = function() {
    var user;

    user = new models.User({
      name: "Michal Srb",
      _id: "ms6611",
      password: "admin",
      email: "ms6611@erial.ac.uk",
      facebook: "xixixao",
      topics: [
        {
          code: "222",
          permission: 'w'
        }
      ]
    });
    return Q.ninvoke(user, 'save').then(function() {
      var topic;

      topic = new models.Topic({
        name: "Models of Computation",
        _id: "222",
        types: ["Notes", "Tutorials", "Solutions"],
        files: [
          {
            _id: 'intro',
            name: "Introduction and Methods",
            type: 'Notes',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611",
            questions: [
              {
                owner: "ms6611",
                text: "I am not sure what this means. Please help me I am lost I need some solutions as fast as you can! please help!!! help!!! I am not sure what this means. Please help me I am lost I need some solutions as fast as you can! please help!!! help!!! I am not sure what this means. Please help me I am lost I need some solutions as fast as you can! please help!!! help!!! I am not sure what this means. Please help me I am lost I need some solutions as fast as you can! please help!!! help!!!",
                position: "[\"[200, 600, 1]\",\"[400, 700, 1]\"]",
                comments: [
                  {
                    owner: "ms6611",
                    text: "Interesting question."
                  }, {
                    owner: "ms6611",
                    text: "Or just a stupid one."
                  }, {
                    owner: "ms6611",
                    text: "Or just a stupid one."
                  }
                ],
                answers: [
                  {
                    owner: "ms6611",
                    text: "I think the answer is 'awesome'.",
                    comments: [
                      {
                        owner: "ms6611",
                        text: "A lion?"
                      }, {
                        owner: "ms6611",
                        text: "A cat for sure."
                      }
                    ]
                  }, {
                    owner: "ms6611",
                    text: "I think it is concerned with the abdominal spacial features of enlarged natural language complexities."
                  }
                ]
              }, {
                owner: "ms6611",
                text: "How come?",
                position: "[\"[300, 100, 1]\",\"[500, 200, 1]\"]"
              }
            ]
          }, {
            _id: 'uninformed-search',
            name: "Uninformed Search",
            type: 'Notes',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'informed-search',
            name: "Informed Search",
            type: 'Notes',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'adversarial-search',
            name: "Adversarial Search",
            type: 'Notes',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'planning-and logic',
            name: "Planning and Logic",
            type: 'Notes',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'planning-algorithms',
            name: "Planning Algorithms",
            type: 'Notes',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'krr',
            name: "KRR",
            type: 'Notes',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'semanticweb',
            name: "SemanticWeb",
            type: 'Notes',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'nmr',
            name: "NMR",
            type: 'Notes',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'introlearning',
            name: "IntroLearning",
            type: 'Notes',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'reinflearning',
            name: "ReinfLearning",
            type: 'Notes',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'abdarg',
            name: "AbdArg",
            type: 'Notes',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'tutorial-1',
            name: "Tutorial 1",
            type: 'Tutorials',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'tutorial-2',
            name: "Tutorial 2",
            type: 'Tutorials',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'tutorial-3',
            name: "Tutorial 3",
            type: 'Tutorials',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'tutorial-4',
            name: "Tutorial 4",
            type: 'Tutorials',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'tutorial-5',
            name: "Tutorial 5",
            type: 'Tutorials',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'solution-1',
            name: "Solution 1",
            type: 'Solutions',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'solution-2',
            name: "Solution 2",
            type: 'Solutions',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'solution-3',
            name: "Solution 3",
            type: 'Solutions',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'solution-4',
            name: "Solution 4",
            type: 'Solutions',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }, {
            _id: 'solution-5',
            name: "Solution 5",
            type: 'Solutions',
            date: new Date(Date.UTC(2013, 6, 5)),
            owner: "ms6611"
          }
        ]
      });
      return Q.ninvoke(topic, 'save');
    });
  };

  connect();

}).call(this);
