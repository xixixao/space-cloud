// Generated by CoffeeScript 1.6.2
(function() {
  var Q, compile, connect, defineModels, models, mongoose, mongooseIncr, populate, shallowify, wipe;

  Q = require('q');

  (require('./q-each'))(Q);

  mongoose = require('mongoose');

  (require('./mongoose-promise-save'))(mongoose);

  mongooseIncr = require('./mongoose-auto-incr');

  defineModels = function() {
    var Answer, CommentA, CommentQ, Event, File, Question, Schema, Topic, User, answerSchema, commentASchema, commentQSchema, eventSchema, fileSchema, questionSchema, topicPermission, topicSchema, userSchema;

    Schema = mongoose.Schema;
    mongooseIncr.loadAutoIncr(mongoose.connection);
    topicPermission = Schema({
      code: {
        type: String,
        ref: 'Topic'
      },
      permission: String
    });
    eventSchema = Schema({
      type: String,
      url: {},
      model: String,
      timestamp: {
        type: Date,
        "default": Date.now
      },
      topicCode: {
        type: String,
        ref: 'Topic'
      }
    });
    Event = mongoose.model('Event', eventSchema);
    userSchema = Schema({
      name: String,
      _id: {
        type: String,
        unique: true
      },
      password: String,
      email: String,
      facebook: String,
      topics: [topicPermission]
    });
    User = mongoose.model('User', userSchema);
    commentASchema = Schema({
      timestamp: {
        type: Date,
        "default": Date.now
      },
      owner: {
        type: String,
        ref: 'User'
      },
      text: String
    });
    commentASchema.methods.shallow = function() {
      return shallowify(this, CommentA);
    };
    commentASchema.statics.findByURL = function(url) {
      return Answer.findByURL(url).then(function(_arg) {
        var answer, comment, parents;

        answer = _arg[0], parents = _arg[1];
        comment = answer.comments.id(url.commentId);
        parents.answer = answer;
        return [comment, parents];
      });
    };
    commentASchema.statics.findShallowByURL = function(url) {
      return compile(CommentA.findByURL(url));
    };
    CommentA = mongooseIncr.model('CommentA', commentASchema);
    answerSchema = Schema({
      timestamp: {
        type: Date,
        "default": Date.now
      },
      owner: {
        type: String,
        ref: 'User'
      },
      comments: [commentASchema],
      text: String,
      votesFor: [
        {
          type: String,
          ref: 'User'
        }
      ],
      priority: Number
    });
    answerSchema.methods.shallow = function() {
      return shallowify(this, Answer, ['comments']);
    };
    answerSchema.statics.findByURL = function(url) {
      return Question.findByURL(url).then(function(_arg) {
        var answer, parents, question;

        question = _arg[0], parents = _arg[1];
        answer = question.answers.id(url.answerId);
        parents.question = question;
        return [answer, parents];
      });
    };
    answerSchema.statics.findShallowByURL = function(url) {
      return compile(Answer.findByURL(url));
    };
    Answer = mongooseIncr.model('Answer', answerSchema);
    commentQSchema = Schema({
      timestamp: {
        type: Date,
        "default": Date.now
      },
      owner: {
        type: String,
        ref: 'User'
      },
      text: String
    });
    commentQSchema.methods.shallow = function() {
      return shallowify(this, CommentQ);
    };
    commentQSchema.statics.findByURL = function(url) {
      return Question.findByURL(url).then(function(_arg) {
        var comment, parents, question;

        question = _arg[0], parents = _arg[1];
        comment = question.comments.id(url.commentId);
        parents.question = question;
        return [comment, parents];
      });
    };
    commentQSchema.statics.findShallowByURL = function(url) {
      return compile(CommentQ.findByURL(url));
    };
    CommentQ = mongooseIncr.model('CommentQ', commentQSchema);
    questionSchema = Schema({
      createdTime: {
        type: Date
      },
      modifiedQuestionTime: {
        type: Date
      },
      modifiedTime: {
        type: Date
      },
      owner: {
        type: String,
        ref: 'User'
      },
      position: String,
      answers: [answerSchema],
      comments: [commentQSchema],
      text: String
    });
    questionSchema.methods.shallow = function() {
      return shallowify(this, Question, ['answers', 'comments']);
    };
    questionSchema.statics.findByURL = function(url) {
      return File.findByURL(url).then(function(_arg) {
        var file, parents, question;

        file = _arg[0], parents = _arg[1];
        question = file.questions.id(url.questionId);
        parents.file = file;
        return [question, parents];
      });
    };
    questionSchema.statics.findShallowByURL = function(url) {
      return compile(Question.findByURL(url));
    };
    Question = mongooseIncr.model('Question', questionSchema);
    fileSchema = Schema({
      _id: {
        type: String,
        unique: true
      },
      path: String,
      name: String,
      owner: {
        type: String,
        ref: 'User'
      },
      questions: [questionSchema],
      type: String,
      date: {
        type: Date
      }
    });
    fileSchema.methods.shallow = function() {
      return shallowify(this, File, ['questions']);
    };
    fileSchema.statics.findByURL = function(_arg) {
      var fileId, topicId;

      topicId = _arg.topicId, fileId = _arg.fileId;
      return Topic.findByURL({
        topicId: topicId
      }).then(function(_arg1) {
        var topic;

        topic = _arg1[0];
        return [
          topic.files.id(fileId), {
            topic: topic
          }
        ];
      });
    };
    fileSchema.statics.findShallowByURL = function(url) {
      return compile(File.findByURL(url));
    };
    File = mongoose.model('File', fileSchema);
    topicSchema = Schema({
      name: String,
      _id: {
        type: String,
        unique: true
      },
      files: [fileSchema],
      types: [String]
    });
    topicSchema.methods.shallow = function() {
      return Q.when(this.toObject({
        transform: function(doc, ret) {
          delete ret.files;
          delete ret.types;
          return ret;
        }
      }));
    };
    topicSchema.statics.findByURL = function(_arg) {
      var topicId;

      topicId = _arg.topicId;
      return Q.ninvoke(Topic, 'findById', topicId).then(function(topic) {
        if (topic == null) {
          throw [404, "topic not found " + topicId];
        }
        return [topic];
      });
    };
    Topic = mongoose.model('Topic', topicSchema);
    return {
      Topic: Topic,
      User: User,
      File: File,
      Question: Question,
      CommentA: CommentA,
      CommentQ: CommentQ,
      Answer: Answer,
      Event: Event
    };
  };

  module.exports = models = defineModels();

  module.exports.named = function(name) {
    return mongoose.model(name);
  };

  shallowify = function(doc, model, dontShow) {
    return Q.ninvoke(model, 'populate', doc, {
      path: 'owner',
      select: 'name _id'
    }).then(function(doc) {
      return doc.toObject({
        transform: function(doc, ret) {
          var key, _i, _len;

          if (dontShow != null) {
            for (_i = 0, _len = dontShow.length; _i < _len; _i++) {
              key = dontShow[_i];
              delete ret[key];
            }
          }
          return ret;
        }
      });
    });
  };

  compile = function(promise) {
    return promise.then(function(_arg) {
      var doc, map;

      doc = _arg[0], map = _arg[1];
      return doc.shallow().then(function(ret) {
        return Q.map(map, function(parent, label) {
          return parent.shallow().then(function(plain) {
            return ret[label] = plain;
          });
        }).then(function() {
          return ret;
        });
      });
    });
  };

  connect = function() {
    var db;

    mongoose.connect("mongodb://localhost/test");
    db = mongoose.connection;
    return db.on("error", function(error) {
      return console.error("DB error:(are you running the database?)\n", error);
    });
  };

  wipe = function() {
    var db;

    db = mongoose.connection;
    return Q.map(db.collections, function(collection) {
      return Q.ninvoke(collection, 'drop');
    });
  };

  populate = function() {
    var user;

    user = new models.User({
      name: "Michal Srb",
      _id: "ms6611",
      password: "admin",
      email: "ms6611@erial.ac.uk",
      facebook: "xixixao",
      topics: [
        {
          code: "222",
          permission: 'w'
        }
      ]
    });
    return Q.ninvoke(user, 'save').then(function() {
      var topic;

      topic = new models.Topic({
        name: "Models of Computation",
        _id: "240",
        types: ["Notes", "Tutorials", "Solutions"],
        files: []
      });
      Q.ninvoke(topic, 'save');
      topic = new models.Topic({
        name: "Programming I",
        _id: "120.1",
        types: ["Notes", "Exercises", "Tests"],
        files: []
      });
      Q.ninvoke(topic, 'save');
      topic = new models.Topic({
        name: "Laboratory 2",
        _id: "261",
        types: ["Webapps", "Pintos", "Life", "MAlice"],
        files: []
      });
      return Q.ninvoke(topic, 'save');
    });
  };

  connect();

}).call(this);
